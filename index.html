<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Matrix Rotator Visualizer</title>
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
</head>

<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    // Helpers
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const deepCopy = (mat) => mat.map(r => r.slice());

    function generateSequentialMatrix(n) {
      const arr = [];
      let c = 1;
      for (let i = 0; i < n; i++) {
        const row = [];
        for (let j = 0; j < n; j++) row.push(c++);
        arr.push(row);
      }
      return arr;
    }

    // --- First algorithm actions: reverse + transpose ---
    function generateActionsReverseTranspose(n) {
      const acts = [];
      for (let i = 0; i < Math.floor(n / 2); i++) {
        acts.push({ type: "swapRows", i1: i, i2: n - 1 - i, desc: `Reverse: swap row ${i} with row ${n - 1 - i}` });
      }
      for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
          acts.push({ type: "swapCells", a: [i, j], b: [j, i], desc: `Transpose: swap cell (${i},${j}) with (${j},${i})` });
        }
      }
      return acts;
    }

    function applyActionReverseTranspose(mat, action) {
      const m = deepCopy(mat);
      if (!action) return m;
      if (action.type === "swapRows") {
        const tmp = m[action.i1];
        m[action.i1] = m[action.i2];
        m[action.i2] = tmp;
      } else if (action.type === "swapCells") {
        const [i1, j1] = action.a;
        const [i2, j2] = action.b;
        const t = m[i1][j1];
        m[i1][j1] = m[i2][j2];
        m[i2][j2] = t;
      }
      return m;
    }

    // --- Second algorithm actions: pointer-based ---
    function generateActionsPointer(n) {
      const acts = [];
      let l = 0, r = n - 1;
      while (l < r) {
        for (let i = 0; i < r - l; i++) {
          const top = l, bottom = r;

          // Save topLeft
          acts.push({
            type: "save",
            cell: [top, l + i],
            desc: `Save top-left (${top},${l + i})`
          });

          // bottom-left -> top-left
          acts.push({
            type: "move",
            from: [bottom - i, l],
            to: [top, l + i],
            desc: `Move bottom-left (${bottom - i},${l}) → top-left (${top},${l + i})`
          });

          // bottom-right -> bottom-left
          acts.push({
            type: "move",
            from: [bottom, r - i],
            to: [bottom - i, l],
            desc: `Move bottom-right (${bottom},${r - i}) → bottom-left (${bottom - i},${l})`
          });

          // top-right -> bottom-right
          acts.push({
            type: "move",
            from: [top + i, r],
            to: [bottom, r - i],
            desc: `Move top-right (${top + i},${r}) → bottom-right (${bottom},${r - i})`
          });

          // saved top-left -> top-right
          acts.push({
            type: "restore",
            to: [top + i, r],
            fromSaved: [top, l + i],
            desc: `Move saved top-left → top-right (${top + i},${r})`
          });
        }
        r--;
        l++;
      }
      return acts;
    }

    function applyActionPointer(mat, action, saved) {
      const m = deepCopy(mat);
      let newSaved = saved;
      if (!action) return { matrix: m, saved: newSaved };
      if (action.type === "save") {
        newSaved = m[action.cell[0]][action.cell[1]];
      } else if (action.type === "move") {
        const val = m[action.from[0]][action.from[1]];
        m[action.to[0]][action.to[1]] = val;
      } else if (action.type === "restore") {
        m[action.to[0]][action.to[1]] = newSaved;
        newSaved = null;
      }
      return { matrix: m, saved: newSaved };
    }

    // --- Generic Visualizer Component ---
    function Visualizer({ title, algoType }) {
      const [n, setN] = useState(3);
      const [initialMatrix, setInitialMatrix] = useState(() => generateSequentialMatrix(3));
      const [matrix, setMatrix] = useState(() => deepCopy(initialMatrix));
      const [actions, setActions] = useState(() =>
        algoType === "reverseTranspose" ? generateActionsReverseTranspose(3) : generateActionsPointer(3)
      );
      const [index, setIndex] = useState(-1);
      const [playing, setPlaying] = useState(false);
      const [speed, setSpeed] = useState(600);
      const [saved, setSaved] = useState(null);
      const timerRef = useRef(null);

      // Update actions when size changes
      useEffect(() => {
        setActions(algoType === "reverseTranspose" ? generateActionsReverseTranspose(n) : generateActionsPointer(n));
        setInitialMatrix(generateSequentialMatrix(n));
      }, [n]);

      useEffect(() => {
        setMatrix(deepCopy(initialMatrix));
        setIndex(-1);
        setSaved(null);
        setPlaying(false);
      }, [initialMatrix]);

      useEffect(() => {
        if (!playing) {
          clearTimeout(timerRef.current);
          return;
        }
        if (index >= actions.length - 1) {
          setPlaying(false);
          return;
        }
        timerRef.current = setTimeout(() => {
          stepForward();
        }, clamp(speed, 50, 5000));
        return () => clearTimeout(timerRef.current);
      }, [playing, index, actions, speed]);

      function stepForward() {
        if (index + 1 >= actions.length) return;
        const next = actions[index + 1];
        if (algoType === "reverseTranspose") {
          setMatrix(prev => applyActionReverseTranspose(prev, next));
        } else {
          const result = applyActionPointer(matrix, next, saved);
          setMatrix(result.matrix);
          setSaved(result.saved);
        }
        setIndex(i => i + 1);
      }

      function stepBack() {
        alert("Step back not implemented for this algorithm.");
      }

      function handleReset() {
        setPlaying(false);
        setMatrix(deepCopy(initialMatrix));
        setIndex(-1);
        setSaved(null);
      }

      return (
        <div className="bg-white p-4 rounded-lg shadow">
          <h2 className="text-xl font-bold mb-4">{title}</h2>
          <div className="flex gap-2 mb-3">
            <label>Size:</label>
            <input type="number" min={2} max={8} value={n}
              onChange={e => setN(Number(e.target.value))}
              className="w-16 border rounded px-1" />
            <button className="px-2 border rounded" onClick={() => setInitialMatrix(generateSequentialMatrix(n))}>
              Reset Seq
            </button>
          </div>
          <div className="flex gap-2 mb-3">
            <button className="px-3 py-1 border rounded" onClick={stepBack} disabled={index < 0}>◀ Step</button>
            <button className="px-3 py-1 border rounded" onClick={() => setPlaying(p => !p)}>{playing ? "⏸ Pause" : "▶ Play"}</button>
            <button className="px-3 py-1 border rounded" onClick={stepForward} disabled={index >= actions.length - 1}>Step ▶</button>
            <button className="px-3 py-1 border rounded" onClick={handleReset}>Reset</button>
          </div>

          <div className="grid"
            style={{ gridTemplateColumns: `repeat(${n}, 48px)`, gap: "6px" }}>
            {matrix.map((row, i) =>
              row.map((val, j) => (
                <div key={`${i}-${j}`} className="h-12 w-12 flex items-center justify-center border rounded font-semibold">
                  {val}
                </div>
              ))
            )}
          </div>

          <div className="mt-3 text-sm">
            Step: {Math.max(0, index + 1)} / {actions.length}
            <div>{index >= 0 ? actions[index].desc : "(not started)"}</div>
          </div>
        </div>
      );
    }

    function App() {
      return (
        <div className="p-6 space-y-6">
          <Visualizer title="Algo 1: Reverse Rows + Transpose" algoType="reverseTranspose" />
          <Visualizer title="Algo 2: Pointer (Top/Bottom/Left/Right)" algoType="pointer" />
        </div>
      );
    }

    ReactDOM.render(<App />, document.getElementById("root"));
  </script>
</body>
</html>
